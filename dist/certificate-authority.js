"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = require("fs");
const rimraf_1 = require("rimraf");
const debug_1 = tslib_1.__importDefault(require("debug"));
const constants_1 = require("./constants");
const platforms_1 = tslib_1.__importDefault(require("./platforms"));
const utils_1 = require("./utils");
const certificates_1 = require("./certificates");
const debug = debug_1.default('devcert:certificate-authority');
/**
 * Install the once-per-machine trusted root CA. We'll use this CA to sign
 * per-app certs.
 */
function installCertificateAuthority(options = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug(`Checking if older devcert install is present`);
        scrubOldInsecureVersions();
        debug(`Generating a root certificate authority`);
        let rootKeyPath = utils_1.mktmp();
        debug(`Generating the OpenSSL configuration needed to setup the certificate authority`);
        seedConfigFiles();
        debug(`Generating a private key`);
        certificates_1.generateKey(rootKeyPath);
        debug(`Generating a CA certificate`);
        utils_1.openssl(`req -new -x509 -config "${constants_1.caSelfSignConfig}" -key "${rootKeyPath}" -out "${constants_1.rootCACertPath}" -days 825`);
        debug('Saving certificate authority credentials');
        yield saveCertificateAuthorityCredentials(rootKeyPath);
        debug(`Adding the root certificate authority to trust stores`);
        yield platforms_1.default.addToTrustStores(constants_1.rootCACertPath, options);
    });
}
exports.default = installCertificateAuthority;
/**
 * Older versions of devcert left the root certificate keys unguarded and
 * accessible by userland processes. Here, we check for evidence of this older
 * version, and if found, we delete the root certificate keys to remove the
 * attack vector.
 */
function scrubOldInsecureVersions() {
    // Use the old verion's logic for determining config directory
    let configDir;
    if (constants_1.isWindows && process.env.LOCALAPPDATA) {
        configDir = path_1.default.join(process.env.LOCALAPPDATA, 'devcert', 'config');
    }
    else {
        let uid = process.getuid && process.getuid();
        let userHome = (constants_1.isLinux && uid === 0) ? path_1.default.resolve('/usr/local/share') : require('os').homedir();
        configDir = path_1.default.join(userHome, '.config', 'devcert');
    }
    // Delete the root certificate keys, as well as the generated app certificates
    debug(`Checking ${configDir} for legacy files ...`);
    [
        path_1.default.join(configDir, 'openssl.conf'),
        path_1.default.join(configDir, 'devcert-ca-root.key'),
        path_1.default.join(configDir, 'devcert-ca-root.crt'),
        path_1.default.join(configDir, 'devcert-ca-version'),
        path_1.default.join(configDir, 'certs')
    ].forEach((filepath) => {
        if (fs_1.existsSync(filepath)) {
            debug(`Removing legacy file: ${filepath}`);
            rimraf_1.sync(filepath);
        }
    });
}
/**
 * Initializes the files OpenSSL needs to sign certificates as a certificate
 * authority, as well as our CA setup version
 */
function seedConfigFiles() {
    // This is v2 of the devcert certificate authority setup
    fs_1.writeFileSync(constants_1.caVersionFile, '2');
    // OpenSSL CA files
    fs_1.writeFileSync(constants_1.opensslDatabaseFilePath, '');
    fs_1.writeFileSync(constants_1.opensslSerialFilePath, '01');
}
function withCertificateAuthorityCredentials(cb) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug(`Retrieving devcert's certificate authority credentials`);
        let tmpCAKeyPath = utils_1.mktmp();
        let caKey = yield platforms_1.default.readProtectedFile(constants_1.rootCAKeyPath);
        fs_1.writeFileSync(tmpCAKeyPath, caKey);
        yield cb({ caKeyPath: tmpCAKeyPath, caCertPath: constants_1.rootCACertPath });
        fs_1.unlinkSync(tmpCAKeyPath);
    });
}
exports.withCertificateAuthorityCredentials = withCertificateAuthorityCredentials;
function saveCertificateAuthorityCredentials(keypath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug(`Saving devcert's certificate authority credentials`);
        let key = fs_1.readFileSync(keypath, 'utf-8');
        yield platforms_1.default.writeProtectedFile(constants_1.rootCAKeyPath, key);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VydGlmaWNhdGUtYXV0aG9yaXR5LmpzIiwic291cmNlUm9vdCI6IkQ6L2Rldi9zb3VyY2Uvbm9kZS9kZXZjZXJ0LyIsInNvdXJjZXMiOlsiY2VydGlmaWNhdGUtYXV0aG9yaXR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHdEQUF3QjtBQUN4QiwyQkFLWTtBQUNaLG1DQUF3QztBQUN4QywwREFBZ0M7QUFFaEMsMkNBU3FCO0FBQ3JCLG9FQUEwQztBQUMxQyxtQ0FBeUM7QUFDekMsaURBQTZDO0FBRzdDLE1BQU0sS0FBSyxHQUFHLGVBQVcsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBRTNEOzs7R0FHRztBQUNILHFDQUEwRCxVQUFtQixFQUFFOztRQUM3RSxLQUFLLENBQUMsOENBQThDLENBQUMsQ0FBQztRQUN0RCx3QkFBd0IsRUFBRSxDQUFDO1FBRTNCLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1FBQ2pELElBQUksV0FBVyxHQUFHLGFBQUssRUFBRSxDQUFDO1FBRTFCLEtBQUssQ0FBQyxnRkFBZ0YsQ0FBQyxDQUFDO1FBQ3hGLGVBQWUsRUFBRSxDQUFDO1FBRWxCLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1FBQ2xDLDBCQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFekIsS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7UUFDckMsZUFBTyxDQUFDLDJCQUEyQiw0QkFBZ0IsV0FBVyxXQUFXLFdBQVcsMEJBQWMsYUFBYSxDQUFDLENBQUM7UUFFakgsS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7UUFDbEQsTUFBTSxtQ0FBbUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUV2RCxLQUFLLENBQUMsdURBQXVELENBQUMsQ0FBQztRQUMvRCxNQUFNLG1CQUFlLENBQUMsZ0JBQWdCLENBQUMsMEJBQWMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsRSxDQUFDO0NBQUE7QUFyQkQsOENBcUJDO0FBRUQ7Ozs7O0dBS0c7QUFDSDtJQUNFLDhEQUE4RDtJQUM5RCxJQUFJLFNBQWlCLENBQUM7SUFDdEIsSUFBSSxxQkFBUyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFO1FBQ3pDLFNBQVMsR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUN0RTtTQUFNO1FBQ0wsSUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDN0MsSUFBSSxRQUFRLEdBQUcsQ0FBQyxtQkFBTyxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkcsU0FBUyxHQUFHLGNBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUN2RDtJQUVELDhFQUE4RTtJQUM5RSxLQUFLLENBQUMsWUFBWSxTQUFTLHVCQUF1QixDQUFDLENBQUM7SUFDcEQ7UUFDRSxjQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUM7UUFDcEMsY0FBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUscUJBQXFCLENBQUM7UUFDM0MsY0FBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUscUJBQXFCLENBQUM7UUFDM0MsY0FBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsb0JBQW9CLENBQUM7UUFDMUMsY0FBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDO0tBQzlCLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDckIsSUFBSSxlQUFNLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDcEIsS0FBSyxDQUFDLHlCQUF5QixRQUFRLEVBQUUsQ0FBQyxDQUFBO1lBQzFDLGFBQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNsQjtJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7R0FHRztBQUNIO0lBQ0Usd0RBQXdEO0lBQ3hELGtCQUFTLENBQUMseUJBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM5QixtQkFBbUI7SUFDbkIsa0JBQVMsQ0FBQyxtQ0FBdUIsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUN2QyxrQkFBUyxDQUFDLGlDQUFxQixFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRCw2Q0FBMEQsRUFBa0c7O1FBQzFKLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1FBQ2hFLElBQUksWUFBWSxHQUFHLGFBQUssRUFBRSxDQUFDO1FBQzNCLElBQUksS0FBSyxHQUFHLE1BQU0sbUJBQWUsQ0FBQyxpQkFBaUIsQ0FBQyx5QkFBYSxDQUFDLENBQUM7UUFDbkUsa0JBQVMsQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDL0IsTUFBTSxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSwwQkFBYyxFQUFFLENBQUMsQ0FBQztRQUNsRSxlQUFFLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbkIsQ0FBQztDQUFBO0FBUEQsa0ZBT0M7QUFFRCw2Q0FBbUQsT0FBZTs7UUFDaEUsS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7UUFDNUQsSUFBSSxHQUFHLEdBQUcsaUJBQVEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDckMsTUFBTSxtQkFBZSxDQUFDLGtCQUFrQixDQUFDLHlCQUFhLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDL0QsQ0FBQztDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7XHJcbiAgdW5saW5rU3luYyBhcyBybSxcclxuICByZWFkRmlsZVN5bmMgYXMgcmVhZEZpbGUsXHJcbiAgd3JpdGVGaWxlU3luYyBhcyB3cml0ZUZpbGUsXHJcbiAgZXhpc3RzU3luYyBhcyBleGlzdHNcclxufSBmcm9tICdmcyc7XHJcbmltcG9ydCB7IHN5bmMgYXMgcmltcmFmIH0gZnJvbSAncmltcmFmJztcclxuaW1wb3J0IGNyZWF0ZURlYnVnIGZyb20gJ2RlYnVnJztcclxuXHJcbmltcG9ydCB7XHJcbiAgcm9vdENBS2V5UGF0aCxcclxuICByb290Q0FDZXJ0UGF0aCxcclxuICBjYVNlbGZTaWduQ29uZmlnLFxyXG4gIG9wZW5zc2xTZXJpYWxGaWxlUGF0aCxcclxuICBvcGVuc3NsRGF0YWJhc2VGaWxlUGF0aCxcclxuICBpc1dpbmRvd3MsXHJcbiAgaXNMaW51eCxcclxuICBjYVZlcnNpb25GaWxlXHJcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgY3VycmVudFBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm1zJztcclxuaW1wb3J0IHsgb3BlbnNzbCwgbWt0bXAgfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgZ2VuZXJhdGVLZXkgfSBmcm9tICcuL2NlcnRpZmljYXRlcyc7XHJcbmltcG9ydCB7IE9wdGlvbnMgfSBmcm9tICcuL2luZGV4JztcclxuXHJcbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ2RldmNlcnQ6Y2VydGlmaWNhdGUtYXV0aG9yaXR5Jyk7XHJcblxyXG4vKipcclxuICogSW5zdGFsbCB0aGUgb25jZS1wZXItbWFjaGluZSB0cnVzdGVkIHJvb3QgQ0EuIFdlJ2xsIHVzZSB0aGlzIENBIHRvIHNpZ25cclxuICogcGVyLWFwcCBjZXJ0cy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGluc3RhbGxDZXJ0aWZpY2F0ZUF1dGhvcml0eShvcHRpb25zOiBPcHRpb25zID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBkZWJ1ZyhgQ2hlY2tpbmcgaWYgb2xkZXIgZGV2Y2VydCBpbnN0YWxsIGlzIHByZXNlbnRgKTtcclxuICBzY3J1Yk9sZEluc2VjdXJlVmVyc2lvbnMoKTtcclxuXHJcbiAgZGVidWcoYEdlbmVyYXRpbmcgYSByb290IGNlcnRpZmljYXRlIGF1dGhvcml0eWApO1xyXG4gIGxldCByb290S2V5UGF0aCA9IG1rdG1wKCk7XHJcblxyXG4gIGRlYnVnKGBHZW5lcmF0aW5nIHRoZSBPcGVuU1NMIGNvbmZpZ3VyYXRpb24gbmVlZGVkIHRvIHNldHVwIHRoZSBjZXJ0aWZpY2F0ZSBhdXRob3JpdHlgKTtcclxuICBzZWVkQ29uZmlnRmlsZXMoKTtcclxuXHJcbiAgZGVidWcoYEdlbmVyYXRpbmcgYSBwcml2YXRlIGtleWApO1xyXG4gIGdlbmVyYXRlS2V5KHJvb3RLZXlQYXRoKTtcclxuXHJcbiAgZGVidWcoYEdlbmVyYXRpbmcgYSBDQSBjZXJ0aWZpY2F0ZWApO1xyXG4gIG9wZW5zc2woYHJlcSAtbmV3IC14NTA5IC1jb25maWcgXCIke2NhU2VsZlNpZ25Db25maWd9XCIgLWtleSBcIiR7cm9vdEtleVBhdGh9XCIgLW91dCBcIiR7cm9vdENBQ2VydFBhdGh9XCIgLWRheXMgODI1YCk7XHJcblxyXG4gIGRlYnVnKCdTYXZpbmcgY2VydGlmaWNhdGUgYXV0aG9yaXR5IGNyZWRlbnRpYWxzJyk7XHJcbiAgYXdhaXQgc2F2ZUNlcnRpZmljYXRlQXV0aG9yaXR5Q3JlZGVudGlhbHMocm9vdEtleVBhdGgpO1xyXG5cclxuICBkZWJ1ZyhgQWRkaW5nIHRoZSByb290IGNlcnRpZmljYXRlIGF1dGhvcml0eSB0byB0cnVzdCBzdG9yZXNgKTtcclxuICBhd2FpdCBjdXJyZW50UGxhdGZvcm0uYWRkVG9UcnVzdFN0b3Jlcyhyb290Q0FDZXJ0UGF0aCwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPbGRlciB2ZXJzaW9ucyBvZiBkZXZjZXJ0IGxlZnQgdGhlIHJvb3QgY2VydGlmaWNhdGUga2V5cyB1bmd1YXJkZWQgYW5kXHJcbiAqIGFjY2Vzc2libGUgYnkgdXNlcmxhbmQgcHJvY2Vzc2VzLiBIZXJlLCB3ZSBjaGVjayBmb3IgZXZpZGVuY2Ugb2YgdGhpcyBvbGRlclxyXG4gKiB2ZXJzaW9uLCBhbmQgaWYgZm91bmQsIHdlIGRlbGV0ZSB0aGUgcm9vdCBjZXJ0aWZpY2F0ZSBrZXlzIHRvIHJlbW92ZSB0aGVcclxuICogYXR0YWNrIHZlY3Rvci5cclxuICovXHJcbmZ1bmN0aW9uIHNjcnViT2xkSW5zZWN1cmVWZXJzaW9ucygpIHtcclxuICAvLyBVc2UgdGhlIG9sZCB2ZXJpb24ncyBsb2dpYyBmb3IgZGV0ZXJtaW5pbmcgY29uZmlnIGRpcmVjdG9yeVxyXG4gIGxldCBjb25maWdEaXI6IHN0cmluZztcclxuICBpZiAoaXNXaW5kb3dzICYmIHByb2Nlc3MuZW52LkxPQ0FMQVBQREFUQSkge1xyXG4gICAgY29uZmlnRGlyID0gcGF0aC5qb2luKHByb2Nlc3MuZW52LkxPQ0FMQVBQREFUQSwgJ2RldmNlcnQnLCAnY29uZmlnJyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGxldCB1aWQgPSBwcm9jZXNzLmdldHVpZCAmJiBwcm9jZXNzLmdldHVpZCgpO1xyXG4gICAgbGV0IHVzZXJIb21lID0gKGlzTGludXggJiYgdWlkID09PSAwKSA/IHBhdGgucmVzb2x2ZSgnL3Vzci9sb2NhbC9zaGFyZScpIDogcmVxdWlyZSgnb3MnKS5ob21lZGlyKCk7XHJcbiAgICBjb25maWdEaXIgPSBwYXRoLmpvaW4odXNlckhvbWUsICcuY29uZmlnJywgJ2RldmNlcnQnKTtcclxuICB9XHJcblxyXG4gIC8vIERlbGV0ZSB0aGUgcm9vdCBjZXJ0aWZpY2F0ZSBrZXlzLCBhcyB3ZWxsIGFzIHRoZSBnZW5lcmF0ZWQgYXBwIGNlcnRpZmljYXRlc1xyXG4gIGRlYnVnKGBDaGVja2luZyAke2NvbmZpZ0Rpcn0gZm9yIGxlZ2FjeSBmaWxlcyAuLi5gKTtcclxuICBbXHJcbiAgICBwYXRoLmpvaW4oY29uZmlnRGlyLCAnb3BlbnNzbC5jb25mJyksXHJcbiAgICBwYXRoLmpvaW4oY29uZmlnRGlyLCAnZGV2Y2VydC1jYS1yb290LmtleScpLFxyXG4gICAgcGF0aC5qb2luKGNvbmZpZ0RpciwgJ2RldmNlcnQtY2Etcm9vdC5jcnQnKSxcclxuICAgIHBhdGguam9pbihjb25maWdEaXIsICdkZXZjZXJ0LWNhLXZlcnNpb24nKSxcclxuICAgIHBhdGguam9pbihjb25maWdEaXIsICdjZXJ0cycpXHJcbiAgXS5mb3JFYWNoKChmaWxlcGF0aCkgPT4ge1xyXG4gICAgaWYgKGV4aXN0cyhmaWxlcGF0aCkpIHtcclxuICAgICAgZGVidWcoYFJlbW92aW5nIGxlZ2FjeSBmaWxlOiAke2ZpbGVwYXRofWApXHJcbiAgICAgIHJpbXJhZihmaWxlcGF0aCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyB0aGUgZmlsZXMgT3BlblNTTCBuZWVkcyB0byBzaWduIGNlcnRpZmljYXRlcyBhcyBhIGNlcnRpZmljYXRlXHJcbiAqIGF1dGhvcml0eSwgYXMgd2VsbCBhcyBvdXIgQ0Egc2V0dXAgdmVyc2lvblxyXG4gKi9cclxuZnVuY3Rpb24gc2VlZENvbmZpZ0ZpbGVzKCkge1xyXG4gIC8vIFRoaXMgaXMgdjIgb2YgdGhlIGRldmNlcnQgY2VydGlmaWNhdGUgYXV0aG9yaXR5IHNldHVwXHJcbiAgd3JpdGVGaWxlKGNhVmVyc2lvbkZpbGUsICcyJyk7XHJcbiAgLy8gT3BlblNTTCBDQSBmaWxlc1xyXG4gIHdyaXRlRmlsZShvcGVuc3NsRGF0YWJhc2VGaWxlUGF0aCwgJycpO1xyXG4gIHdyaXRlRmlsZShvcGVuc3NsU2VyaWFsRmlsZVBhdGgsICcwMScpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aENlcnRpZmljYXRlQXV0aG9yaXR5Q3JlZGVudGlhbHMoY2I6ICh7IGNhS2V5UGF0aCwgY2FDZXJ0UGF0aCB9OiB7IGNhS2V5UGF0aDogc3RyaW5nLCBjYUNlcnRQYXRoOiBzdHJpbmcgfSkgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQpIHtcclxuICBkZWJ1ZyhgUmV0cmlldmluZyBkZXZjZXJ0J3MgY2VydGlmaWNhdGUgYXV0aG9yaXR5IGNyZWRlbnRpYWxzYCk7XHJcbiAgbGV0IHRtcENBS2V5UGF0aCA9IG1rdG1wKCk7XHJcbiAgbGV0IGNhS2V5ID0gYXdhaXQgY3VycmVudFBsYXRmb3JtLnJlYWRQcm90ZWN0ZWRGaWxlKHJvb3RDQUtleVBhdGgpO1xyXG4gIHdyaXRlRmlsZSh0bXBDQUtleVBhdGgsIGNhS2V5KTtcclxuICBhd2FpdCBjYih7IGNhS2V5UGF0aDogdG1wQ0FLZXlQYXRoLCBjYUNlcnRQYXRoOiByb290Q0FDZXJ0UGF0aCB9KTtcclxuICBybSh0bXBDQUtleVBhdGgpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzYXZlQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyhrZXlwYXRoOiBzdHJpbmcpIHtcclxuICBkZWJ1ZyhgU2F2aW5nIGRldmNlcnQncyBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgY3JlZGVudGlhbHNgKTtcclxuICBsZXQga2V5ID0gcmVhZEZpbGUoa2V5cGF0aCwgJ3V0Zi04Jyk7XHJcbiAgYXdhaXQgY3VycmVudFBsYXRmb3JtLndyaXRlUHJvdGVjdGVkRmlsZShyb290Q0FLZXlQYXRoLCBrZXkpO1xyXG59XHJcbiJdfQ==